# lec6 SPOC思考题


NOTICE
- 有"w3l2"标记的题是助教要提交到学堂在线上的。
- 有"w3l2"和"spoc"标记的题是要求拿清华学分的同学要在实体课上完成，并按时提交到学生对应的git repo上。
- 有"hard"标记的题有一定难度，鼓励实现。
- 有"easy"标记的题很容易实现，鼓励实现。
- 有"midd"标记的题是一般水平，鼓励实现。

## 与视频相关思考题

### 6.1	非连续内存分配的需求背景
 1. 为什么要设计非连续内存分配机制？

    因为连续内存分配机制分配给程序的物理内存必须连续，因此存在内碎片和外碎片，且内存分配的动态修改困难。最终导致内存利用率较低。


 1. 非连续内存分配中内存分块大小有哪些可能的选择？大小与大小是否可变?

    一种是每一段为一块，空间较大，大小可变。一种是以每一页为一块，空间较小，大小固定。


 1. 为什么在大块时要设计大小可变，而在小块时要设计成固定大小？小块时的固定大小可以提供多种选择吗？

    较小的块会导致分配的块数量更多，固定大小方便寻址和管理，小块时的固定大小可以事先提供不同选择。

    较大的块数量较少，因此采取可变大小更加灵活。

### 6.2	段式存储管理
 1. 什么是段、段基址和段内偏移？

    段：表示访问方式和存储数据等属性相同的一段地质空间。对应一个连续的内存块，若干个段组成进程的逻辑地质空间。

    段基址：一个段在物理空间中的起始地址。

    段偏移：一条数据或者代码在所处段相对起始位置的地址。


 1. 段式存储管理机制的地址转换流程是什么？为什么在段式存储管理中，各段的存储位置可以不连续？这种做法有什么好处和麻烦？

    转换流程：首先通过段号查询段描述副，找到段基址，与段内偏移相加得到物理地址。

    段的划分反映了程序的储存逻辑结构，程序通常不会从一个段去访问另一个段内的数据，所以不同段可以存储位置不连续。

    带来的好处在于方便内存管理，没有内部碎片，提高内存利用率，缺点在于地址转换变得复杂，需要段表来查找对应段的位置。。


### 6.3	页式存储管理
 1. 什么是页（page）、帧（frame）、页表（page table）、存储管理单元（MMU）、快表（TLB, Translation Lookaside Buffer）和高速缓存（cache）？

    帧：把物理地址空间划分成大小相同的基本分配单位，每一块为2的n次方

    页：把逻辑地址空间划分成相同大小的基本分配单位，与帧的大小保持一致。

    页表：由页表基址和页号的方式查询帧号，将逻辑地址空间的每一个页号对应到物理地址空间中的一个帧号。

 1. 页式存储管理机制的地址转换流程是什么？为什么在页式存储管理中，各页的存储位置可以不连续？这种做法有什么好处和麻烦？
    地址转换是页号+页内偏移。

    将逻辑地址的后几位看成偏移梁，前几位看成页号，通过在页表中页表基址+页号，找到页号对应帧号，然后利用帧号和地址偏移量构成物理空间地址，然后查询。通过这种方式就可以让存储位置不连续。

    好处在于方便内存的分配和回收，不会产生外部碎片。缺点在于页表的建立需要时间，且每一页较小，导致页表本身会很大。页表式储存管理导致每次出巡需要两次内存访问，频繁查找页表影响开销。


### 6.4	页表概述
 1. 每个页表项有些什么内容？有哪些标志位？它们起什么作用？

    页表项：包括帧号，各个页表标志位（存在位、修改位、引用位）

    存在位：一个逻辑页号是否在物理内存中对应一个帧号，如果对应就是1。

    修改位：表示对应的页面是否修改。

    引用位：表示这个页面在过去一段时间内是否有过对他的引用。

 1. 页表大小受哪些因素影响？

    每一页的大小，地址空间的大小，进程的数目。


### 6.5	快表和多级页表
 1. 快表（TLB）与高速缓存（cache）有什么不同？

    TLB使用关联存储器实现。

 1. 为什么快表中查找物理地址的速度非常快？它是如何实现的？为什么它的的容量很小？

    因为TLB在CPU执行，访问速度很快，并且CPU中的关联存储器可以并行的同时查找所有表项。因为速度快、成本高、功耗大，所以容量就很小。

 1. 什么是多级页表？多级页表中的地址转换流程是什么？多级页表有什么好处和麻烦？

    多级页表：通过间接引用将页号分为多级。

    第一级偏移通过第一级页表查询第二级页表的起始，然后和第二级偏移一起查询第三集页表的起始，一直到第K级的起始+第K级的偏移查找到帧号，和帧内偏移一起得到物理地址。

    好处就是减少每级页表的长度。和页表总体大小。

    缺点，K级页表每次要查询K+1次。


### 6.6	反置页表
 1. 页寄存器机制的地址转换流程是什么？

    对逻辑地址进行hash映射，在TLB中查询对应页表项，有冲突时遍历冲突项链表，查找失败产生异常。

 1. 反置页表机制的地址转换流程是什么？

    进程标识和页号一起做hash映射，然后查找相应页寄存器。核对PID和页号。处理冲突。

 1. 反置页表项有些什么内容？

    包括使用位（是否被进程占用），占用页号（对应页号），保护位（可读可写）

### 6.7	段页式存储管理
 1. 段页式存储管理机制的地址转换流程是什么？这种做法有什么好处和麻烦？

    段号+段表基址查询出页表基址，与页号相加得到帧号，帧号与帧内偏移相加得到物理地址。

    既可以利用段机制实现内存保护，又可以利用页机制提高内存利用率。

 1. 如何实现基于段式存储管理的内存共享？

    通过指向相同的页表基址，实现进程间的段共享。

 1. 如何实现基于页式存储管理的内存共享？

    通过指向相同的帧号，实现页共享

## 个人思考题
（1） (w3l2) 请简要分析64bit CPU体系结构下的分页机制是如何实现的



## 小组思考题
（1）(spoc) 某系统使用请求分页存储管理，若页在内存中，满足一个内存请求需要150ns (10^-9s)。若缺页率是10%，为使有效访问时间达到0.5us(10^-6s),求不在内存的页面的平均访问时间。请给出计算步骤。



（2）(spoc) 有一台假想的计算机，页大小（page size）为32 Bytes，支持32KB的虚拟地址空间（virtual address space）,有4KB的物理内存空间（physical memory），采用二级页表，一个页目录项（page directory entry ，PDE）大小为1 Byte,一个页表项（page-table entries
PTEs）大小为1 Byte，1个页目录表大小为32 Bytes，1个页表大小为32 Bytes。页目录基址寄存器（page directory base register，PDBR）保存了页目录表的物理地址（按页对齐）。

PTE格式（8 bit） :
```
  VALID | PFN6 ... PFN0
```
PDE格式（8 bit） :
```
  VALID | PT6 ... PT0
```
其
```
VALID==1表示，表示映射存在；VALID==0表示，表示映射不存在。
PFN6..0:页帧号
PT6..0:页表的物理基址>>5
```
在[物理内存模拟数据文件](./03-2-spoc-testdata.md)中，给出了4KB物理内存空间的值，请回答下列虚地址是否有合法对应的物理内存，请给出对应的pde index, pde contents, pte index, pte contents。
```
1) Virtual Address 6c74
   Virtual Address 6b22
2) Virtual Address 03df
   Virtual Address 69dc
3) Virtual Address 317a
   Virtual Address 4546
4) Virtual Address 2c03
   Virtual Address 7fd7
5) Virtual Address 390e
   Virtual Address 748b
```

比如答案可以如下表示： (注意：下面的结果是错的，你需要关注的是如何表示)
```
Virtual Address 7570:
  --> pde index:0x1d  pde contents:(valid 1, pfn 0x33)
    --> pte index:0xb  pte contents:(valid 0, pfn 0x7f)
      --> Fault (page table entry not valid)

Virtual Address 21e1:
  --> pde index:0x8  pde contents:(valid 0, pfn 0x7f)
      --> Fault (page directory entry not valid)

Virtual Address 7268:
  --> pde index:0x1c  pde contents:(valid 1, pfn 0x5e)
    --> pte index:0x13  pte contents:(valid 1, pfn 0x65)
      --> Translates to Physical Address 0xca8 --> Value: 16
```

[链接](https://piazza.com/class/i5j09fnsl7k5x0?cid=664)有上面链接的参考答案。请比较你的结果与参考答案是否一致。如果不一致，请说明原因。

（3）请基于你对原理课二级页表的理解，并参考Lab2建页表的过程，设计一个应用程序（可基于python、ruby、C、C++、LISP、JavaScript等）可模拟实现(2)题中描述的抽象OS，可正确完成二级页表转换。

[链接](https://piazza.com/class/i5j09fnsl7k5x0?cid=664)有上面链接的参考答案。请比较你的结果与参考答案是否一致。如果不一致，提交你的实现，并说明区别。

（4）假设你有一台支持[反置页表](http://en.wikipedia.org/wiki/Page_table#Inverted_page_table)的机器，请问你如何设计操作系统支持这种类型计算机？请给出设计方案。

 (5)[X86的页面结构](http://os.cs.tsinghua.edu.cn/oscourse/OS2019spring/lecture06)
---

## 扩展思考题

阅读64bit IBM Powerpc CPU架构是如何实现[反置页表](http://en.wikipedia.org/wiki/Page_table#Inverted_page_table)，给出分析报告。


## interactive　understand VM

[Virtual Memory with 256 Bytes of RAM](http://blog.robertelder.org/virtual-memory-with-256-bytes-of-ram/)：这是一个只有256字节内存的一个极小计算机系统。按作者的[特征描述](https://github.com/RobertElderSoftware/recc#what-can-this-project-do)，它具备如下的功能。
 - CPU的实现代码不多于500行；
 - 支持14条指令、进程切换、虚拟存储和中断；
 - 用C实现了一个小的操作系统微内核可以在这个CPU上正常运行；
 - 实现了一个ANSI C89编译器，可生成在该CPU上运行代码；
 - 该编译器支持链接功能；
 - 用C89, Python, Java, Javascript这4种语言实现了该CPU的模拟器；
 - 支持交叉编译；
 - 所有这些只依赖标准C库。

针对op-cpu的特征描述，请同学们通过代码阅读和执行对自己有兴趣的部分进行分析，给出你的分析结果和评价。
